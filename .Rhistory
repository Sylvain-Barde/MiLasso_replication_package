if (sel[j,2] == acsign ) { #Use only feasible unselected evecs
xe <- cbind(X, vec[,j])  #Add test eigenvector
res1 <- y - xe %*% solve(crossprod(xe), crossprod(xe, y)) #res = y - xe(ex'ex)^(-1)(ex'y)
mi <- (crossprod(res1, V) %*% res1) / crossprod(res1) #mi = (res'S)res/res'res
if (ExactEV) {
M <- diag(nrow(X)) - xe %*% solve(crossprod(xe),t(xe))
MStat <- GetMoranStat(MSM=M %*% V %*% M, degfree=nrow(X)-ncol(xe))
}
if (abs((mi - MStat$Mean) / sqrt(MStat$Var)) < z) { #Identify min z(Moran)
MinMi = mi
z <- (MinMi - MStat$Mean) / sqrt(MStat$Var)
idx =j
}
}
}  #End inner loop
#Update design matrix permanently by selected eigenvector
X <- cbind(X,vec[,idx])
M <- diag(nrow(X)) - X %*% solve(crossprod(X),t(X))
#Update Expectation and Variance
MStat <- GetMoranStat(MSM= M %*% V %*% M, degfree=nrow(X) - ncol(X))
ZMinMi <- ((MinMi - MStat$Mean) / sqrt(MStat$Var))
betagam <- solve(crossprod(X),crossprod(X,y)) #b=(X'X)^(-1)(X'Y)
res <- y - X %*% betagam # residuals = Y - Xb
sigma2_hat <- crossprod(res) / (nrow(X) - ncol(X))
se<-sqrt(diag(c(sigma2_hat) * solve(crossprod(X)))) #calculate se
#Add results of i-th step
out <- c(i,
idx,
MinMi,
ZMinMi)
Aout <- rbind(Aout, out)
#To exclude the selected eigenvector in the next loop
sel[idx,2] <- 0
if (is.na(ZMinMi)) {
break
} else if (abs(ZMinMi) < tol){
break
}
} # End Outer Loop
colnames(Aout) <- c("Step","SelEvec","MinMi","ZMinMi")
return(Aout)
}
MiLasso <- function(y, X, V, E, A=A, no_con=no_con){
#arguments
# y <-y_sp # dependant variable
# X <- X1 # Matrix of Exonegnous variables
# V <- V # forced symetric SWM
# E <- E # Eigenvectors
if (no_con==TRUE){
Xcon <- X
}else{
Xcon <- cbind(X,rep(1,nrow(X)))
}
M_X <- diag(1, nrow(X)) - Xcon %*% solve(crossprod(Xcon),t(Xcon)) #projection matrix
MStat <- GetMoranStat(MSM = M_X%*%V%*%M_X, degfree = nrow(X) - ncol(Xcon)) #Moran E and Var
res <- y - Xcon %*% solve(crossprod(Xcon),crossprod(Xcon,y)) # residuals = y - xhat*b
mI <- (crossprod(res, V) %*% res) / crossprod(res) #mi = (res'S)res/res'res
zI <- (mI - MStat[["Mean"]]) / sqrt(MStat[["Var"]])
theta <- abs(zI)^{-A} # absolute vlaue of the inverse of the morans I
pen <- c(rep(0,ncol(X)),rep(1,ncol(E)))
XE <- cbind(X,E) # design matrix
fit = glmnet(XE, y, lambda = theta, penalty.factor =pen) # Milasso
###
#find selected evecs for Miplasso
if((fit$df - ncol(X))==0){ # no eigenvectors selected
if (no_con==TRUE){
Miplasso <- lm(y ~ X-1) # simple ols model
}else{
Miplasso <- lm(y ~ X) # simple ols model
}
selV=NA
} else {
Temp <- as.matrix(cbind(fit[["beta"]],seq(1,nrow(fit[["beta"]])),0))
Temp[,3] <- (Temp[,1] > 0 | Temp[,1] < 0)  # asign non-zero evecs value 1
sel_no  <-  Temp[,2]*Temp[,3]
Ext	= subset(sel_no,sel_no!=0)		#extracted eigenvectors
Exx		= XE[,Ext]
selV		= Exx[,-(1:ncol(X))]
if (no_con==TRUE){
Miplasso <- lm(y ~ X + selV - 1) # # post lasso
}else{
Miplasso <- lm(y ~ X + selV) # post lasso
}
}
y_bar=y-E%*%as.vector(fit[["beta"]][-(1:ncol(X))])
if (is.na(selV)[1]){ #no eigenvectors selected
if(no_con==TRUE){ #exclude constant
MiLasso <- lm(y_bar ~ X-1)
} else{  #include constant
MiLasso <- lm(y_bar ~ X)
}
}else{
m_E <- diag(nrow(E)) - selV %*%  t(selV) # projection matix for swm
if(no_con==TRUE){ #exclude constant
MiLasso <- lm(y_bar ~ m_E%*%X-1)
} else{  #include constant
MiLasso <- lm(y_bar ~ m_E%*%X)
}
}
return(list("p.Mi.Lasso"=Miplasso, "n.Mi.Lasso"=fit, "Mi.Lasso"=MiLasso, no_selected=(fit$df - ncol(X)), mI= mI,
zI=zI, E_s=as.matrix(selV)))
}
#######################################################################################################
##spatial weight matrix construction and spectoral decompostion
W 	= as.matrix(nb2mat(boston.soi,style="B")) # generate saptial weight matrix
W_mm = W/max(rowSums(W)) # max sum normalise
egW 	= eigen(W_mm)	#Extracting eigenvectors from modified SWM
egvec = egW$vectors
egval = egW$values
colnames(egvec)=rep(1:n)
######################################################################################
#OLS
ols <- lm(Y~X)
#########################################################################################################
##FstepZ
FstepZ_start <- Sys.time() # start timer
FstepZ <- grif_ESF(y=Y, X=X, V=W_mm, vec=egvec, val=egval, ExactEV = FALSE, tol = 0.1)
Fstepz_sel_no <- sort(FstepZ[-1,2]) #extracted eigenvectors number
Fstepz_sel		= egvec[,Fstepz_sel_no]
FstepZ_reg <- lm(Y~X+Fstepz_sel)
FstepZ_end <- Sys.time() # end timer
#######################################################################################################
##CV-LASSO
cvlasso_start <- Sys.time() # start timer
LASSOecv_x 	= optL1(Y,penalized=egvec,unpenalized=X,fold=20, model="linear",standardize=T)	#Kfold CV
LASSOe_x 	= penalized(Y,penalized=egvec,unpenalized=X,model="linear",lambda1=LASSOecv_x$lambda,standardize=T)
coef_x		= as.data.frame(coefficients(LASSOe_x,"penalized"))
rownames(coef_x) = colnames(egvec)
#Eigenvectors which is not zero
xx			= as.numeric(rownames(coef_x))*ifelse(coef_x!=0,1,0)
CVlasso_sel_no	= subset(xx,xx!=0)		#extracted eigenvectors number
CVlasso_sel		= egvec[,CVlasso_sel_no]
CVplasso	= lm(Y~X+CVlasso_sel)	 # post lasso
cvlasso_end <- Sys.time() # end timer
#######################################################################################################
##Mi-Lasso
Milasso_start <- Sys.time() # start timer
milasso <-  MiLasso(y=Y, X=X, V=W_mm, E=egvec, A=2, no_con=FALSE)
Milasso_end <- Sys.time() # end timer
#computational times
FstepZ_end - FstepZ_start
cvlasso_end - cvlasso_start
Milasso_end - Milasso_start
#print the regression results for the four models
models <- list("simple.OLS"=ols, "FstepZ"=FstepZ_reg,"post.CV.Lasso"= CVplasso,
"Mi.Lasso"=milasso[["Mi.Lasso"]])
for(i in 1:length(models)){ # prints regression results
print("********************************")
print(paste0("Result in colum ", i, " of Table 3 in main paper and 15 in supplement"))
print(names(models)[i])
print(format(round(coeftest(models[[i]], vcov = vcovHC(models[[i]], type = "HC1")),3), nsmall = 3))
# print(coeftest(models[[i]], vcov = vcovHC(models[[i]], type = "HC1"))) # uncomment for unrounded results
}
#set working directory
setwd('C:/Users/cm1rcxx/Documents/GitHub/evip_ml/classification_sim1/')
#install.packages("randomForest") #random forest package
library(randomForest)
renv::deactivate()
############################################
# main_class_case1.r
# EVPPI classifcation case study one
#
# By Rowan Cherodian (r.cherodian@sheffield.ac.uk)
#################################################
remove(list = ls()) #clear environment
# load packages
library(MASS)
library(mgcv)
#install.packages("xtable") # package to produce latex table
library(xtable)
#set working directory
setwd('C:/Users/cm1rcxx/Documents/GitHub/evip_ml/classification_sim1/')
set.seed(2018)
options(scipen = 999) # disable scientific notation
data.paper <- TRUE  # if false, SAVI data specification used
S <- 10000            # S is the simulation size for the Monte Carlo computation of SE and bias
############################
#setup for simulations
#
#by rowan cherodian
############################
remove(list = ls()) #clear environment
library(MASS)
set.seed(2018)
#### Case study 1
p <- 28           # number of parameters (total)
N <- 1e4         # number of draws
lambda <- 10000   # willingness to pay threshold
distr <- as.data.frame(matrix(c(1000,  1,    # X1 cost of drug
0.1,   0.02, # X2 % Admissions
5.2,   1,    # X3 Days in hospital [in SAVI sd = 2, in paper sd = 1]
400,   200,  # X4 Costs per day (same for t=1 and t=2)
0.7,   0.1,  # X5 % Responding
0.3,   0.1,  # X6 Change in utility if respond
3.0,   0.5,  # X7 Duration of response
0.25,  0.1,  # X8 % Side effects
-0.1,  0.02, # X9 Change in utility if side effect
0.5,   0.2,  # X10 Duration of side effect
1500,  1,    # X11 cost of drug
0.08,  0.02, # X12 % Admissions
6.1,   1,    # X13 Days in hospital
0.8,   0.1,  # X14 % Responding
0.3,   0.05, # X15 Change in utility if respond
3.0,   1.0,  # X16 Duration of response
0.2,   0.05, # X17 % Side effects
-0.1,  0.02, # X18 Change in utility if side effect
0.5,   0.2, # X19 Duration of side effect
2000,  1,    # X20 cost of drug
0.06,  0.02, # X21 % Admissions
7.1,   1,    # X22 Days in hospital
0.9,   0.1,  # X23 % Responding
0.3,   0.05, # X24 Change in utility if respond
3.0,   1.0,  # X25 Duration of response
0.15,  0.05, # X26 % Side effects
-0.1,  0.02, # X27 Change in utility if side effect
0.5,   0.2), # X28 Duration of side effect
ncol = 2, nrow = p, byrow = T))
colnames(distr) <- c("mean", "sd")
#
# if (data.paper == F){
#   distr$sd[3] <- 2
# }
#
# rho <- 0.6                # correlation coefficient
# Sigma <- matrix(NA, p, p) # covariance matrix
# for (i in 1:p) {
#   for (j in 1:p) {
#     if (i %in% c(5, 7, 14, 16) & j %in% c(5, 7, 14, 16)) {
#       Sigma[i, j] <- rho * distr$sd[i] * distr$sd[j]
#     } else if (i %in% c(6, 15) & j %in% c(6, 15)) {         # in SAVI data these parameters not correlated
#       Sigma[i, j] <- rho * distr$sd[i] * distr$sd[j]
#       if (data.paper == F) {
#         Sigma[i, j] <- 0
#       }
#     } else {
#       Sigma[i, j] <- 0
#     }
#     if (i == j) {
#       Sigma[i, j] <- (distr$sd[i])^2
#     }
#   }
# }
meanvector <- distr$mean #  c(1000.00, 0.10, 5.20, 400.00, 0.70, 0.30, 3.00, 0.25, -0.10, 0.50, 1500.00, 0.08, 6.10, 0.80, 0.30, 3.00, 0.20, -0.10, 0.50)
stdvector <- distr$sd    #  c(1, .02, 1, 200, 0.1, 0.1, .5,0.1, .02, .2, 1, .02, 1, .1,.05,  1, .05, .02, .2)
n.inputs <- p
rho <- 0.6
cormatrix <- diag(n.inputs)
cormatrix[5, 7] <- cormatrix[7, 5] <- rho
cormatrix[5, 14] <- cormatrix[14, 5] <- rho
cormatrix[5, 16] <- cormatrix[16, 5] <- rho
cormatrix[7, 14] <- cormatrix[14, 7] <- rho
cormatrix[7, 16] <- cormatrix[16, 7] <- rho
cormatrix[14, 16] <- cormatrix[16, 14] <- rho
cormatrix[23, 7] <- cormatrix[7, 23] <- rho
cormatrix[23, 14] <- cormatrix[14, 23] <- rho
cormatrix[23, 16] <- cormatrix[16, 23] <- rho
cormatrix[25, 14] <- cormatrix[14, 25] <- rho
cormatrix[25, 16] <- cormatrix[16, 25] <- rho
cormatrix[23, 25] <- cormatrix[25, 23] <- rho
cormatrix[5, 25] <- cormatrix[25, 5] <- rho
cormatrix[5, 23] <- cormatrix[23, 5] <- rho
cormatrix[7, 25] <- cormatrix[25, 7] <- rho
# cormatrix[6, 15] <- cormatrix[15, 6] <- rho # CORRELATION WAS ZERO IN PAPER CASE STUDY CODE
Sigma <- diag(stdvector) %*% cormatrix %*% diag(stdvector)
sample <- mvrnorm(n = N, mu = meanvector, Sigma = Sigma) # for analytic computation
#cov2cor(Sigma)
#sqrt(diag(Sigma))
calc_c <- function(par, sample.size = N){
costs <- as.data.frame(matrix(NA, sample.size, 3))
costs[, 1] <- par[, 1] + par[, 2] * par[, 3] * par[, 4]
costs[, 2] <- par[, 11] + par[, 12] * par[, 13] * par[, 4]
costs[, 3] <- par[, 20] + par[, 21] * par[, 22] * par[, 4]
return(costs)
}
calc_e <- function(par, sample.size = N){
effects <- as.data.frame(matrix(NA, sample.size, 3))
effects[, 1] <- par[, 5] * par[, 6] * par[, 7] + par[, 8] * par[, 9 ] * par[, 10]
effects[, 2] <- par[, 14] * par[, 15] * par[, 16] + par[, 17] * par[, 18] * par[, 19]
effects[, 3] <- par[, 23] * par[, 24] * par[, 25] + par[, 26] * par[, 27] * par[, 28]
return(effects)
}
#check this which column to minus to get the inb
calc_inb <- function(costs, effects, lambda){
nb <- as.matrix(effects) * lambda - as.matrix(costs)
inb <- nb - nb[, 1]
return(inb)
}
calc_nb <- function(costs, effects, lambda){
nb <- as.matrix(effects) * lambda - as.matrix(costs)
return(nb)
}
costs_sample   <- calc_c(sample)
effects_sample <- calc_e(sample)
inb_sample     <- calc_inb(costs_sample, effects_sample, lambda)
nb_sample      <- calc_nb(costs_sample, effects_sample, lambda)
#write.csv(costs_sample, "costs_sample.csv", row.names = F)
#write.csv(effects_sample, "effects_sample.csv", row.names = F)
#write.csv(sample, "parameters_sample.csv", row.names = F)
# 2 equivalent ways of computing EVPI (from the sample)
EVPI1 <- mean(pmax(nb_sample[,1], nb_sample[,2], nb_sample[,3])) -
max(mean(nb_sample[,1]), mean(nb_sample[,2]),mean(nb_sample[,3]))
EVPI1 # think this is correct check with MARK ^^
EVPI2 <- mean(pmax(0, inb_sample[, 2],inb_sample[, 3])) -
max(0, mean(inb_sample[, 2]), mean(inb_sample[, 3]))   #check this is correct
EVPI2
#############
### EVPPI ###
#############
# all parameter sets
phi_sets <- list(set1 = c(5, 14, 23),
set2 = c(5, 6, 14, 15, 23, 24),
set3 = c(7, 16, 25))
summary(inb_sample)
best <- (apply(inb_sample, 1, which.max))
best <- factor(best)
best
levels(best) # no 3
levels(best) # no 3
dominated <- setdiff(1:ncol(inb), levels(best))
levels(best) # no 3
dominated <- setdiff(1:ncol(inb_sample), levels(best))
dominated
EVPI2 <- mean(pmax(0, inb_sample[, 2],inb_sample[, 3])) -
max(0, mean(inb_sample[, 2]), mean(inb_sample[, 3]))   #check this is correct
EVPI2
EVPI3 <- mean(pmax(0, inb_sample[, 2],inb_sample[, 3])) -
max(colMeans(inb_sample))   #check this is correct
EVPI3
EVPI1 <- mean(pmax(nb_sample[,1], nb_sample[,2], nb_sample[,3])) -
max(mean(nb_sample[,1]), mean(nb_sample[,2]),mean(nb_sample[,3]))
EVPI1 # think this is correct check with MARK ^^
EVPI1 <- mean(pmax(nb_sample[,1], nb_sample[,2], nb_sample[,3])) -
max(colMeans(nb_sample))
EVPI1 # think this is correct check with MARK ^^
EVPI2 <- mean(pmax(0, inb_sample[, 2],inb_sample[, 3])) -
max(colMeans(inb_sample))   #check this is correct
EVPI2
EVPI3 <- mean(apply(inb_sample, 1, max))  -
max(colMeans(inb_sample))#check this is correct
EVPI3
############################################
# main_class_case1.r
# EVPPI classifcation case study one
#
# By Rowan Cherodian (r.cherodian@sheffield.ac.uk)
#################################################
remove(list = ls()) #clear environment
# load packages
library(MASS)
library(mgcv)
#install.packages("xtable") # package to produce latex table
library(xtable)
#set working directory
setwd('C:/Users/cm1rcxx/Documents/GitHub/evip_ml/classification_sim1/')
set.seed(2018)
options(scipen = 999) # disable scientific notation
data.paper <- TRUE  # if false, SAVI data specification used
S <- 10000            # S is the simulation size for the Monte Carlo computation of SE and bias
train_prob <- 0.6 # probability in training data set
n_boot <- 1000 # number of bootstrap replication of SE SVM
########################
#  MAKE 'TIME' TABLES  #
########################
# initialize table with computing times
# time <- as.data.frame(matrix(NA, nrow = 7, ncol = 3)) # for now 7 sets of results
# rownames(time) <- c("one-level MC", "two-level MC (K<J)", "two-level MC (K=J)", "two-level MC (K>J)",
#                      "GP", "GP-INLA", "GP1-vec", "GP2-vec")
# colnames(time) <- c("parameter set 1",	"parameter set 2",	"parameter set 3")
# RUN ALL METHODS AS SEPARATE FILES
source("replicate_setup3d.R")   ; print(paste("setup", Sys.time()))
source("ml_pred_d_svm.R")      ; print(paste("SVM", Sys.time()))
train_prob
train_prob
train_prob <- 0.6 # probability in training data set
############################################
# main_class_case1.r
# EVPPI classifcation case study one
#
# By Rowan Cherodian (r.cherodian@sheffield.ac.uk)
#################################################
remove(list = ls()) #clear environment
# load packages
library(MASS)
library(mgcv)
#install.packages("xtable") # package to produce latex table
library(xtable)
#set working directory
setwd('C:/Users/cm1rcxx/Documents/GitHub/evip_ml/classification_sim1/')
set.seed(2025)
options(scipen = 999) # disable scientific notation
data.paper <- TRUE  # if false, SAVI data specification used
S <- 10000            # S is the simulation size for the Monte Carlo computation of SE and bias
train_prob <- 0.6 # probability in training data set
n_boot <- 1000 # number of bootstrap replication of SE SVM
########################
#  MAKE 'TIME' TABLES  #
########################
# initialize table with computing times
# time <- as.data.frame(matrix(NA, nrow = 7, ncol = 3)) # for now 7 sets of results
# rownames(time) <- c("one-level MC", "two-level MC (K<J)", "two-level MC (K=J)", "two-level MC (K>J)",
#                      "GP", "GP-INLA", "GP1-vec", "GP2-vec")
# colnames(time) <- c("parameter set 1",	"parameter set 2",	"parameter set 3")
# RUN ALL METHODS AS SEPARATE FILES
source("replicate_setup3d.R")   ; print(paste("setup", Sys.time()))
source("replicate_analytic.R"); print(paste("analytic", Sys.time()))
source("replicate_2loop.R")   ; print(paste("2-loop", Sys.time()))
source("ml_pred_d_svm.R")      ; print(paste("SVM", Sys.time()))
source("ml_pred_d_svm.R")      ; print(paste("SVM", Sys.time()))
svm_results
svm_res$evppi[set] <- svm_results$partial.evppi
svm_res$evppi[set] <- svm_results$partial.evppi
svm_res$se[set]    <- svm_results$evppi.se
svm_res$time[set] <-  svm_results$evppi.time
svm_res$total[set] <- svm_results$n.evppi
###########################
#ml_pred_d_svm.R
#predict d by SVM
#by rowan cherodian
###########################
library(e1071) #SVM package
svm_evppi <- function(INB, input.parameters, inputs.of.interest, n.boot,
train.prob, dmax_inb){
#argumments
# INB = inb
# input.parameters = paramters
# inputs.of.interest = phi
# n.boot <- 1000 #number of bootstrap replications for SE
# train.prob <- 0.70 # share to data used fro training
# dmax_inb <- best
#
svm_evppi_stat <- function(model, data, inb){ #function to calculate evppi
svm.pred <- as.numeric(as.character(predict(model,data, type = "class"))) #predict conditional INB decision
inb_hat_svm <-  inb[cbind(1:nrow(inb), svm.pred)] #extract predicted conditional INB value
evppi <- mean(inb_hat_svm) - max(colMeans(inb)) #calculate evppi
return(evppi)
}
start <- Sys.time()
data <- as.data.frame(cbind(input.parameters[,phi],"dmax"=dmax_inb))
data$dmax <- as.factor(data$dmax)
# split data into training and test datasets
ind <- sample(2, nrow(input.parameters), replace = TRUE, prob = c(train.prob, 1-train.prob))
train <- data[ind==1,]
test <- data[ind==2,]
inb_test <- as.matrix(INB[ind==2,]) #extract inc net benfit for prediction (test data)
svm_mod <- svm(dmax ~ ., data = train, kernel = "radial",
type = 'C-classification') #estimate SVM on training data
partial.evppi <- svm_evppi_stat(model=svm_mod, data=test, inb=inb_test) #predicted evppi on test data
end <- Sys.time()
boot_evppi <- c()
for(j in 1:n.boot){
indx <- sample(x = 1:nrow(inb_test), size = nrow(inb_test), replace = TRUE) ## sample indices
boot_inb <- inb_test[indx,] ## temp data set
boot_test <- test[indx,] ## temp data set
boot_evppi[j] <-  svm_evppi_stat(model=svm_mod, data=boot_test, inb=boot_inb) #predicted evppi on bootstrap test data
}
evppi.se <-  sd(boot_evppi)
n.evppi <- sum(ind==2)
evppi.time <-  difftime(end, start, units = 'secs')
return(list(partial.evppi=partial.evppi,evppi.se=evppi.se, evppi.time=evppi.time , n.evppi=n.evppi))
}
svm_res <- as.data.frame(matrix(NA, nrow = length(phi_sets), ncol = 9)) # evppi and se
colnames(svm_res) <- c("estimator", "inner_loop", "outer_loop", "total", "coefs", "evppi", "se", "ub", "time")
boot_reps <- 10 # number of bootstrap replication for SE
svm_res$estimator <- "SVM"
#set <- 1
for (set in 1:length(phi_sets)){
#dataset
phi <- phi_sets[[set]]
svm_res$coefs[set] <-  paste(phi, collapse = ",")
svm_results <- svm_evppi(INB = inb_sample, input.parameters = sample, inputs.of.interest = phi,
n.boot=boot_reps, dmax_inb=best, train.prob=train_prob)
svm_res$evppi[set] <- svm_results$partial.evppi
svm_res$se[set]    <- svm_results$evppi.se
svm_res$time[set] <-  svm_results$evppi.time
svm_res$total[set] <- svm_results$n.evppi
}
svm_res
renv::deactivate()
############################################
# main_class_case1.r
# EVPPI classification case study one
#
# By Rowan Cherodian (r.cherodian@sheffield.ac.uk)
#################################################
remove(list = ls()) #clear environment
# load packages
library(MASS)
library(mgcv)
#install.packages("xtable") # package to produce latex table
library(xtable)
#set working directory
setwd('C:/Users/cm1rcxx/Documents/GitHub/evip_ml/classification_sim1/')
set.seed(2025)
options(scipen = 999) # disable scientific notation
data.paper <- TRUE  # if false, SAVI data specification used
S <- 10000            # S is the simulation size for the Monte Carlo computation of SE and bias
train_prob <- 0.6 # probability in training data set
n_boot <- 1000 # number of bootstrap replication of SE SVM
########################
#  MAKE 'TIME' TABLES  #
########################
# initialize table with computing times
# time <- as.data.frame(matrix(NA, nrow = 7, ncol = 3)) # for now 7 sets of results
# rownames(time) <- c("one-level MC", "two-level MC (K<J)", "two-level MC (K=J)", "two-level MC (K>J)",
#                      "GP", "GP-INLA", "GP1-vec", "GP2-vec")
# colnames(time) <- c("parameter set 1",	"parameter set 2",	"parameter set 3")
# RUN ALL METHODS AS SEPARATE FILES
source("replicate_setup3d.R")   ; print(paste("setup", Sys.time()))
source("replicate_analytic.R"); print(paste("analytic", Sys.time()))
source("replicate_2loop.R")   ; print(paste("2-loop", Sys.time()))
source("replicate_GP.R")      ; print(paste("GP", Sys.time()))
renv::deactivate()
